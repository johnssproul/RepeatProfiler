#!/bin/bash
commands=$@
BASE="refbase_"
num_commands=`echo $commands | wc -w ` #gets the number  of commands
bam_mode="false"

if ((num_commands == 0 )) # if no commands entered, show this
 then

echo "RepeatProfiler v 0.99 -prerelease- x soon x"
echo "use -h flag for help using this tool"
echo "____ ____ ___  ____ ____ ___    ___  ____ ____ ____ _ _    ____ ____"
echo "|__/ |___ |__] |___ |__|  |     |__] |__/ |  | |___ | |    |___ |__/ "
echo "|  \ |___ |    |___ |  |  |     |    |  \ |__| |    | |___ |___ |  \ "

exit 1

fi

rm -f -r  *.out *.bam *fofn* Errors_README.log Single_summary.csv normalized_table.csv #images-RP Single_summary.csv #brew stuff
currentDate=`date`
currentDate=`tr ' :' '_' <<<"$currentDate"`
rm -f Errors_README.txt
echo "generating symlinks"

#brew link --overwrite >/dev/null 2>&1  #brew stuff
#mydir=`echo "$(brew --cellar repeatprof)/0.92/libexec"` #brew stuff
R_packages="default_rpackages"
#R_packages=`echo "$(brew --cellar repeatprof)/0.92/R_packages"` #brew stuff
#images=`echo "$(brew --cellar repeatprof)/0.92/images-RP"`  #brew stuff
#Rscript=`echo "$(brew --prefix R)/bin/Rscript"`  #brew stuff
mydir=`pwd` #comment when running it for brew
mydir="${mydir}/scripts/" #comment when running it for brew
Rscript="Rscript" #comment when running it for brew




##### this block checks for correct command structure and does error handling 

if  [[ $1 == "profile" ]] || [[ $1 == "-cow" ]] || [[ $1 == "corr" ]] ||  [[ $1  ==  "clean" ]] || [[ $1 ==  "-h" ]] || [[ $1 == "pre-corr" ]]; then  # check if the 2nd parameter is any of these. If not, terminate the program and tell the user.
echo "" > /dev/null

else
echo "Incorrect command structure -- invalid first argument after 'repeatprof'. Use 'repeatprof -h' to view valid commands or refer to the manual."
exit 1

fi


currentdir=`pwd`


#bam work in progress 



#







reads=$4

u_or_p_flag=$2


if [ "$1" == "profile" ]; then  # check if the second parameter is profile, If yes then preform profiling stuff


if [ "$u_or_p_flag" == "-bam" ];
then


mkdir temp_work_dir_RP_${currentDate}
 

echo "yes" > temp_work_dir_RP_${currentDate}/test.fastq
ls $reads/*.bam > temp_work_dir_RP_${currentDate}/temp_bamnames.txt

fofn_bamcounts=$(wc -l temp_work_dir_RP_${currentDate}/temp_bamnames.txt | cut -f1 -d " ")
if [[ $fofn_bamcounts == 0 ]];
then
 echo "There are no bam files in the directory provided."
exit 1 
fi


reads="temp_work_dir_RP_${currentDate}/"
bam_mode="true"
u_or_p_flag="-u"
fi

#cp -r $images $currentdir #brew stuff images-RP
if  [[ $u_or_p_flag == "-u" ]] ||  [[ $u_or_p_flag  ==  "-p" ]]; then # check if the user input -u or -p if not give him an error as it is a madantory command
echo "" > /dev/null

else
echo "second parameter should be -u or -p"
exit 1

fi


 if (( num_commands < 4 )) #If commands are less than 4 (which is number of the 4 madantory flags for profile)
 then
echo "Missing madantory arguments for 'profile' command. Use 'repeatprof -h' to view list of mandatory arguments for 'profile' or refer to the manual."
exit 1

fi

commands=$@ #this gets all parameters of a command. It is a shell thing
array=(${commands})   # this is able to put a string separated by spaces in an array, so this basically put the parameters in array
index=0 # this keep track of the index while looping through array by element.

for t in "${array[@]}"  #for each element in the array
do

if [[ $t  ==  "-o" ]]; then # this if statement says if the flag in the array is -o  (stands for output folder directory ) then check for the next element in the array
	((index ++))
	the_path=${array[index]}

	    if [[ -d $the_path ]]; then
		 echo "the output will be directed to  $the_path "

		else
		   echo "Specified output directory path invalid. Specify a valid path (check for blanks in directory names), or omit the -o flag and output will be written to current directory."
		   exit 0
		fi
		
    fi
		((index ++))
done


for t in "${array[@]}"  #for each element in the array
do

rmdup="FALSE"
#checking for flag to remove duplicates or not 
if [[ $t  ==  "-rmdup" ]]; then # this if statement says if the flag in the array is -o  (stands for output folder directory ) then check for the next element in the array
	rmdup="TRUE"


fi
done



# continues checking command structure for optional flags as the example explained above ^

verticalplots="false"	
for t in "${array[@]}"  #for each element in the array
do

if [[ $t  ==  "-vertical" ]]; then # this if statement says if the flag in the array is -o  (stands for output folder directory ) then check for the next element in the array
        echo "vertical color gradient profiles will be produced"
	    verticalplots="true"
    fi
done





The_folder="$currentDate-RP"
mkdir $The_folder # this creates the main output folder
if [[ $bam_mode == "true" ]]; 
then

cp  temp_work_dir_RP_${currentDate}/temp_bamnames.txt $The_folder
rm -fr temp_work_dir_RP_${currentDate}

fi
BASE="refbase_" #this is just for the naming of the refrence index made by bowtie2-build, so it can be detected later when aligning using bowtie2
commands=$@


#refs_full_path=`readlink -f $3`

before_pwd=`pwd`

if [[ -f $user_prov ]]; then
	
	cp  $user_prov $The_folder

elif [ "$infolder" == "true" ]; then 

cp user_groups.txt $The_folder

fi

cd $The_folder
exec > >(tee -i logfile.log)

if [[ -f $3 ]]; then 

refs_full_path=$3

else

refs_full_path=`echo "${before_pwd}/$3"`

fi 

The_folder=${The_folder}_output

mkdir $The_folder

##### detects input reference file(s), prepares them for the run using fasta_splitter script, error handling 

if [[ -d $refs_full_path ]]; then # checking if 3rd parameter (refrence path) for profile is directory or a file
#if it is a directory then sum up all the .fa files and put them int o one and send them to fasta splitter to prepare them as single fasta sequences for analysis
	path_refs=`cat $refs_full_path/*.fa > all_refs.fa`
bash $mydir/fasta_splitter.sh $refs_full_path


retval=$? #check if any error occured by getting the exit code

if [ $retval -eq 2 ]; then #if an error occured and the exit code isn't 0 then exit. The error message will be printed from map_mileup not here
exit 1

elif [ $retval -ne 0 ]; then #if an error occured and the exit code isnt 0  then exit. The error message will be printed from map_mileup not here
	echo "Something is wrong with the file containing reference sequences -- check that it is in fasta format and the last line ends in a carriage return"
exit 1

fi


	refs=references_used #this is where bowtie will look for refrence sequence ot align. It is a sub directory

elif [[ -f $refs_full_path ]]; then # if the reference entered as a file  then just send it to fasta splitter in case it is multi sequence fasta
	rm -f -r references_used
	bash $mydir/fasta_splitter.sh $refs_full_path #split comment


retval=$? #check if any error occured by getting the exit code

if [ $retval -eq 2 ]; then #if an error occured and the exit code isnt 0  then exit. The error message will be printed from map_mileup not here
exit 1

elif [ $retval -ne 0 ]; then #if an error occured and the exit code isnt 0  then exit. The error message will be printed from map_mileup not here
	echo "Something is wrong with the file containing reference sequences -- check that it is in fasta format and the last line ends in a carriage return"
exit 1

fi

refs=references_used

else
    echo "The path to file containing the reference sequence(s)is not valid"
    exit 1

fi


#inserting preparing bam here


if [[ $bam_mode == "true" ]]; 

then

echo "yes in"

bash $mydir/preparing_bam_to_analyze.sh $4 

retval=$? #check if any error occured by getting the exit code

if [[ $retval == 1 ]];
then

exit 1

else

reads=$(pwd)
reads="$reads/badfastqs-temp-RP"
fi

fi

index=0

annotate_file="placeholder"
#work in progress making annotation file
for k in "${array[@]}"
do
((index ++))
if [[ $k  ==  "-bed" ]]; then

bedfile_directory=${array[index]}


echo $bedfile_directory
if [[ -f $bedfile_directory ]]; then
		annotate_file=$bedfile_directory
		 

else

echo "The path provided to the bed file is not found. Please enter FULL path to the bed file"
exit 1
fi
#annotate_file="/mnt/d/Pipeline_project/scriptTest/scriptTest/RepeatProfiler/testing.bed"

grep ">" $refs_full_path | sort | uniq > refnames.txt
sed  "s/>//" refnames.txt > temp_bedref

sed  $'s/[^[:print:]\t]//g'  temp_bedref > temp_bedref2

cat temp_bedref2 >  refnames.txt
rm -f temp_bedref temp_bedref2
grep -f refnames.txt $annotate_file > bedfile_toanalyze.bed
cut  -f1-4 bedfile_toanalyze.bed > temp_bed
cat temp_bed > bedfile_toanalyze.bed 
rm -f temp_bed

bedfileline_count=$(wc -l bedfile_toanalyze.bed | cut -f1 -d " ")
if [[ $bedfileline_count == 0 ]];
then
echo "The bed file entered has no reference names matching the reference file provided or bed file is badly fortmated."

exit 1


else

while read line_bed; 
	do
		echo "changing names in bed"
		line_bed=$(echo $line_bed | cut -f1 -d " "  )
		name_edited=$(echo "$line_bed" | tr ' 	\\<.,:#"/\|?%' '_')

		tr  "$line_bed" "$name_edited" < bedfile_toanalyze.bed  > temp_bed 
		cat temp_bed > bedfile_toanalyze.bed
		
		
	done < bedfile_toanalyze.bed


fi
curpwd=$(pwd)
annotate_file="$curpwd/bedfile_toanalyze.bed"
bed="true"

rm -f temp_bed

fi
done





alt_color="false"
#virdis color flag
for k in "${array[@]}"
do
if [[ $k  ==  "-altcol" ]]; then

alt_color="true"



fi
done


#insert indel check

indel="false"

index=0
indel_cutoff=0.10

for k in "${array[@]}"
do
((index ++))

if [[ $k  ==  "-indel" ]]; then

indel="true"
indel_cutoff=${array[index]}



fi
done

if [[ $indel_cutoff == "" ]];
then

indel_cutoff=0.10

fi

#








#
array=(${commands})
index=0

for p in "${array[@]}"
do
((index ++))

if [[ $p  ==  "-corr" ]]; then
	#((index ++))

##### end command structure checks and error handling




##### this block does an initial check to detect read data, does error handling, and makes relevant files of file names for downstream loops etc.

if [ $u_or_p_flag = "-p" ]; then #if user specified paired data then look for this 

  ls ${reads}/*_R1.fastq ${reads}/*_R1.gz ${reads}/*_R1.fq ${reads}/*_R1.fq.gz  ${reads}/*_1.fq ${reads}/*_1.fq.gz ${reads}/*_1.gz ${reads}/*_1.fastq ${reads}/*_1.fastq.gz > fofn1.txt 2>/dev/null

  ls ${reads}/*_R2.fastq ${reads}/*_R2.gz ${reads}/*_R2.fq ${reads}/*_R2.fq.gz  ${reads}/*_2.fq.gz  ${reads}/*_2.fq ${reads}/*_2.gz ${reads}/*_2.fastq ${reads}/*_2.fastq.gz > fofn2.txt 2>/dev/null

fi

if [ $u_or_p_flag = "-u" ]; then
#if user specified unpaired data then look for that. We make 2 fofn for unpaired data here because downstream code was built on paired data, but in the end the second fofn for unpaired data will be ignored
if [[ -f $reads ]]; then
if [[ $reads == *.fq ]] || [[ $reads == *.fastq ]] || [[ $reads == *.gz ]]; then 
ls $reads > fofn1.txt
ls $reads > fofn2.txt 

else 

echo "The path to the unpaired reads file(s) is incorrect, or the file(s) format is unsupported"
echo "Make sure the path is correct (note that spaces in directory names may cause errors). Make sure read files have '.fastq' or '.fq' extensions. Compressed (i.e., '.gz') formats also accepted (e.g., 'fastq.gz')."
exit 1
fi 

else 
  ls ${reads}/*.fastq ${reads}/*.gz ${reads}/*.fq     > fofn1.txt 2>/dev/null
  ls ${reads}/*.fastq ${reads}/*.gz ${reads}/*.fq    > fofn2.txt 2>/dev/null   #Even though this code is for -u (unpaired data) we still make two fofns that are identical. We do this just as a work around for downstream code, but one of the two will be ignored in the end.

fi 

fi

#checks if the lines of the fofn for pair 1 is equal to lines fofn of pair 2 if not then give an error because that mean user has missing data if paired  
echo "checking reads"
reads1_check=`cat fofn1.txt | wc -l | xargs` 
echo $reads1_check
reads2_check=`cat fofn2.txt | wc -l | xargs`


if [[ $reads1_check == 0 && $reads2_check == 0 ]];then #if both are empty then there was no reads of correct format to begin with 
echo ""
echo "The path to the paired reads file(s) is incorrect, or the file(s) format is not supported"| tee -a Errors_README.log
echo "Make sure the path is correct (note that spaces in directory names may cause errors). Make sure read files have '.fastq' or '.fq' extensions. Compressed (i.e., '.gz') formats also accepted (e.g., 'fastq.gz')."| tee -a Errors_README.log
exit 1

fi

if [ "$reads1_check" != "$reads2_check" ]; then

echo "There is a pair of reads missing. Ensure all reads read pairs are present in input directory"| tee -a Errors_README.log
exit 1

fi


#ls ${DIR}/*.fa > fofn3.txt
#counts number of lines in fofn1.txt and stores variable as MAX
MAX=`wc -l < fofn1.txt`

##### end initial check and error handling for read data 
pwd
echo "checking"

##### checks input file for -corr flag, error handling

	user_prov=${array[index]}

	    if [[ -f $user_prov ]]; then
		rm -f user_groups.txt
		cp $user_prov .
        lines=`cat $user_prov | wc -l`
		lines=`echo $[$lines-1]`
	    if [[ $lines -ne $MAX ]]; then
           echo "Read files listed in user_groups.txt don't match the read files in path to reads you provided for this run. Ensure that user_groups is correctly formatted, and the path to reads is correct."
		   echo "The user_groups.txt file format does not match read format selected for this run (i.e., -p or -u) If user_groups.txt was formatted for unpaired data, -u must be specified for the run. If formatted for paired data, -p must be specified. See help menu or user manual."
		   exit 1 
         fi		
        
		currentdir=`pwd`

		 cp $user_prov  $currentdir
		 
		elif [[ -f $before_pwd/user_groups.txt ]]; then
		cp $before_pwd/user_groups.txt .
        lines=`cat user_groups.txt | wc -l`
		lines=`echo $[$lines-1]`
		echo "$lines"
		infolder=true
	    if [[ $lines -ne $MAX ]]; then
           echo "Read files listed in user_groups.txt don't match the read files in path to reads you provided for this run. Ensure that user_groups is correctly formatted, and the path to reads is correct."
		   echo "The user_groups.txt file format does not match read format selected for this run (i.e., -p or -u) If user_groups.txt was formatted for unpaired data, -u must be specified for the run. If formatted for paired data, -p must be specified. See help menu or user manual."
		   exit 1 
         fi		
	     echo '' > /dev/null

		else

		   echo "File 'user_groups.txt' not found. -corr option requires user-defined groups to be specified in user_groups.txt. This file is not present in the current directory, and no alternative path was provided. See repeatprof -h or user manual for help"
		   echo "Correlation analysis skipped"
		   exit 0

		fi
    
    fi
	((index ++))
done

##### end -corr input check and, error handling. Also end of checks for optional flags (and handling errors) that was supplied with profile command









#this is just to clear out the clutter one-time use intermidiate output 
rm -f -r Errors.log  2> /dev/null
rm *bam *bt2  2> /dev/null
rm -f -r map_depth_allrefs  2> /dev/null

##### end detection, processing and error handling of input reference sequences




mkdir map_depth_allrefs #this creates map_depth_allrefs where it store  a table of postion of reference and the coverage depth (the folder will be used later by $Rscripts)
if [[ $indel == "true" ]];
then
mkdir indel_info_allrefs

fi


Normalized=false #this is equal 1 always unless the user chooses to normalize 

rm -f *out  2> /dev/null




##### This block is for normalization analysis (e.g., -singlecopy flag), detects mapping settings, runs external script, error handling


#cat $refs/*.fa > all_References.fa #the folder where fasta spliter stores all the .fa file after splitting them. This line just gets a list of these references with their paths



# Work in progress




p=8 #this is the deafult threads

commands=$@
array=(${commands})
index=0
#we did this before we will check if -t was entered in optional arguments
for th in "${array[@]}"
do

if [[ $th  ==  "-t" ]]; then
	((index ++))
	p=${array[index]}
	    re='^[0-9]+$'

	if ! [[ $p =~ $re ]] ; then #make sure the user entered a number for threads not some nonsense words
	p=4
	fi
fi
		((index ++))

done
echo "Threads used: $p" #prints to the user what threads is being used


#the following is the same checking for optional flag but this time it is for bowtie settings
a="--very-sensitive-local"
commands=$@
array=(${commands})

for i in "${array[@]}"
do

if [[ $i  ==  "--very-fast" ]] || [[ $i  ==  "--local" ]] || [[ $i  ==  "--fast" ]] || [[ $i  ==  "--sensitive" ]] || [[ $i  == "--very-sensitive" ]] || [[ $i  ==  "--very-fast-local" ]] || [[ $i  ==  "--fast-local" ]] || [[ $i  ==  "--sensitive-local" ]] || [[ $i  ==  "--very-sensitive-local" ]]; then
		a=$i
    fi
done


if [[ $@  ==  *"-D"* ]]; then
commands=$@
a=`echo "$commands" | awk '{for (I=1;I<=NF;I++) if ($I == "-D") {print $I " " $(I+1) " " $(I+2) " " $(I+3)" " $(I+4) " " $(I+5) " " $(I+6) " " $(I+7) " " $(I+8) " " $(I+9) };}' `

fi

if [[ $@  ==  *"-bowtieflag"* ]]; then
commands=$@
a=`echo "$commands" | awk '{for (I=1;I<=NF;I++) if ($I == "-bowtieflag") {print $(I+1) };}' `

fi

echo "Bowtie2 alignment settings: $a"
#exit 1
echo $reads
line="All_references"




#used to be were mapping is done in the past. 

retval=$? #check if any error occured by getting the exit code

if [ $retval -ne 0 ]; then #if an error occured and the exit code isnt 0  then exit. The error message will be printed from map_mileup not here
exit 1
fi

echo "yes"
















#check if singlecopy gene present if singlecopy option selected
for i in "${array[@]}"
do

if [[ $i == "-singlecopy" ]]; then

grep "_singlecopy" all_References.fa | sed 's/^.//'  > fofnsingle.txt

echo ""

fofnsinglecheck=`cat fofnsingle.txt | wc -l`

if [ $fofnsinglecheck == 0 ];then #if both are empty then there was no reads of correct format to begin with
  echo "PROBLEM !"
  echo "No singlecopy genes sequences detected in the reference sequence file you provided. Make sure your single copy reference names in the Fasta file end with '_singlecopy' "
  echo "more info can be found on the github page, or try repeatprof -h "
  exit 1
fi

fi

done








bash $mydir/readme_gen.sh #this starts generating the readme. which will be populated later with the index to read conversions


echo "yes"
echo "$bam_mode"

echo $reads

#continue working here yasta
#bash $mydir/bam_analyses.sh $line $reads $u_or_p_flag $p $a $rmdup
if [[ $bam_mode == "false" ]];
then
##preps references for read mapping in bowtie2
bowtie2-build all_References.fa $BASE 
fi 


##calls map_reads.sh which runs bowtie aligning and uses the indexes we built and also run samtools mpileup
bash $mydir/map_reads.sh $line $reads $u_or_p_flag $p $a $rmdup $bam_mode 


retval=$? 

if [ $retval -ne 0 ]; then #if an error occured and the exit code isnt 0  then exit. The error message will be printed from singlecopy.sh not here
exit 1

fi

echo "mapped reads"


















for i in "${array[@]}"
do

if [[ $i == "-singlecopy" ]]; then
  

a="--very-sensitive-local"
commands=$@
array=(${commands})

for i in "${array[@]}"
do

if [[ $i  ==  "--very-fast" ]] || [[ $i  ==  "--local" ]] || [[ $i  ==  "--fast" ]] || [[ $i  ==  "--sensitive" ]] || [[ $i  == "--very-sensitive" ]] || [[ $i  ==  "--very-fast-local" ]] || [[ $i  ==  "--fast-local" ]] || [[ $i  ==  "--sensitive-local" ]] || [[ $i  ==  "--very-sensitive-local" ]]; then
		a=$i
    
	fi

if [[ $@  ==  *"-D"* ]]; then
commands=$@
a=`echo "$commands" | awk '{for (I=1;I<=NF;I++) if ($I == "-D") {print $I " " $(I+1) " " $(I+2) " " $(I+3)" " $(I+4) " " $(I+5) " " $(I+6) " " $(I+7) " " $(I+8) " " $(I+9) };}' `

fi 
done

echo ""
	echo "The alignment setting for single copy calculations is $a"



#Runs external script for normalization analysis 
bash $mydir/singlecopy.sh $mydir $reads $u_or_p_flag "2" $a $rmdup $refs_full_path





retval=$? 

if [ $retval -ne 0 ]; then #if an error occured and the exit code isnt 0  then exit. The error message will be printed from singlecopy.sh not here
exit 1

fi




Normalized=true
readnumbers=`cat fofnsingle.txt | wc -l`
echo "Normalization values calculated:"
rm -f -r plots_single_copy
mkdir plots_single_copy


$Rscript $mydir/single_copy_calculator.R $readnumbers

$Rscript $mydir/mk_profiles_single.R plots_single_copy $R_packages $Normalized 

mv single_cvs plots_single_copy

mv plots_single_copy $The_folder
pwd
echo ""

echo "Normalization calcaulations ended "
echo ""

##### 
grep  ">" all_References.fa | grep -v "_singlecopy" | sed 's/^.//'  > fofnrefs.txt

else
grep  ">" all_References.fa | sed 's/^.//'  > fofnrefs.txt

fi

done 
#exit 1 # STOP HERE
##### end of normalization (-singlecopy) block 



##### more error handling of input references and preparation for read mapping

#ls $refs/*.fa > fofnrefs.txt  2> /dev/null #the folder where fasta spliter stores all the .fa file after splitting them. This line just gets a list of these references with their paths

fofncheck=`cat fofnrefs.txt | wc -l` 

if [[ $fofncheck == 0 ]];then #if both are empty then there was no reads of correct format to begin with 

echo "Only _singlecopy reference sequences detected in fasta file containing reference sequences." 
echo "The program expects repeat references (lacking _singlecopy in the sequence header) to also be present"

exit 1
fi



echo "Reference	Sample_index	Read1	Read2	Total_reads	percent_mapped" > The_summary.txt #preparing the summary table




##### end above block




##### detects settings for read mapping, maps reads by calling script that runs bowtie2, loops through all references, begins organizing output

while read line  # for each line  in the fofnrefs.txt we will loop through it and carry the following analysis
do

echo "mydir=$mydir">vars.txt

echo "num_commands=$num_commands">>vars.txt
echo "p=$p">>vars.txt
echo "reads=$reads">>vars.txt
echo "refs=$refs">>vars.txt
echo "refs_full_path=$refs_full_path">>vars.txt
echo "retval=$retval">>vars.txt
echo "rmdup=$rmdup">>vars.txt
echo "t=$t">>vars.txt
echo "p=$p">>vars.txt
echo "verticalplots=$verticalplots">>vars.txt
echo "i=$i">>vars.txt
echo "a=$a">>vars.txt
echo "array=$array">>vars.txt
echo "before_pwd=$before_pwd">>vars.txt
echo "commands=$commands">>vars.txt
echo "currentDate=$currentDate">>vars.txt
echo "currentdir=$currentdir">>vars.txt
echo "fofncheck=$fofncheck">>vars.txt
echo "PWD=$PWD">>vars.txt
echo "R_packages=$R_packages">>vars.txt
echo "Rscript=$Rscript">>vars.txt
echo "Normalized=$Normalized">>vars.txt
echo "the_output=$the_output" >>vars.txt
echo "The_folder=$The_folder">>vars.txt
echo "annotate_file=$annotate_file" >> vars.txt
echo "alt_color=$alt_color" >> vars.txt
echo "indel=$indel" >> vars.txt
echo "indel_cutoff=$indel_cutoff" >> vars.txt

#

echo "bash $mydir/analyze_per_ref.sh $line" >> analyzing_refs_commands.txt

#bash $mydir/analyze_per_ref.sh $line 
echo "analyzing reference: $line"
 #this an fi for error handling dont mess with it. this is the end of the reference
done < fofnrefs.txt #keep looping until all references inputed undergone the analysis
cat analyzing_refs_commands.txt | parallel -j $p --will-cite



rm -f Run_summary.csv
$Rscript $mydir/depth_analyser.R $Normalized #run the depth analyzer which produces the final summary table

if [[ -f Single_summary.csv ]]; then 
cat Run_summary.csv Single_summary.csv  > Run_summary2.csv
rm -f Run_summary.csv	
mv Run_summary2.csv Run_summary.csv
fi 

Number=`wc -l < fofn_bam.txt`
rm -f -r scaled_profiles_allrefs
mkdir scaled_profiles_allrefs #this creats folder where the graphs which will be scaled using mk_profiles_all.R stored

echo "Thenumber: $Number"

##### end organization of ouptut




##### calls script to combine color profiles for all references and puts them on the same color scale of coverage depth, more output organization


echo $alt_color
$Rscript $mydir/mk_profiles_all.R $Number $R_packages $Normalized $annotate_file $alt_color $indel $indel_cutoff

mv  scaled_profiles_allrefs $The_folder
mv  *ReadMe*  $The_folder #move read me to the final folder
mv The_summary.txt $The_folder
rm -f The_summary.txt ref_temp.txt bowtie.log  *db.2*

##### end combined color profiles and output organization




##### More prep for correlation analysis, calls external script to do correlation analysis, writes Readmes for output folders, organizes output

if [[ $@  ==  *"-corr"* ]]; then #if the user enter -corr check for user_groups.txt is in the same directory then run it and see if there is errors and run it

rm -f  R_all_correlation_errors.txt

if [[ !(-f user_groups.txt) ]]; then

echo "user_groups.txt was not found -- full correlation analysis skipped " > R_all_correlation_errors.txt

else
rm -f -r correlation_analysis

mkdir correlation_analysis
mkdir correlation_analysis/correlation_data
mkdir correlation_analysis/correlation_histograms
mkdir correlation_analysis/correlation_boxplots_by_group
mkdir correlation_analysis/correlation_boxplots_by_reference

rm -f *_boxplot.pdf*
rm -f correlation_summary.csv 


##calls script for overall correlation analysis
$Rscript $mydir/all_corr.R $R_packages $Normalized

#these echo statements make the ReadMe text file for correlation analysis
echo "*****correlation analysis*****"  > correlation_README.txt  
echo "" >> correlation_README.txt
echo "" >> correlation_README.txt
echo "Four output folders are included in Correlation analysis." >> correlation_README.txt
echo "">> correlation_README.txt
echo "First folder: correlation_boxplots_by_group">> correlation_README.txt
echo " This folder contains boxplots for each group defined in user_groups.txt. The boxplots combine correlation values across all repeat references used in the run. Each group has its own plot.">> correlation_README.txt
echo "">> correlation_README.txt
echo "Second folder: correlation_boxplots_by_reference">> correlation_README.txt
echo " This folder contains boxplots that show correlation of profile shape within and between user-defined groups for individual repeat references in the run.">> correlation_README.txt
echo "">> correlation_README.txt
echo "Third folder: correlation_data">> correlation_README.txt
echo " This folder contains correlation matrices for each reference. The matrices shows all the correlation values among all samples for a reference. Each refrence has its own matrix.">> correlation_README.txt
echo "">> correlation_README.txt
echo "Fourth folder: correlation_histograms">> correlation_README.txt
echo " This folder contains histograms of within and between-group correlation values for each reference.">> correlation_README.txt
echo "">> correlation_README.txt
echo "Last file: correlation_summary.csv">> correlation_README.txt
echo " This table contains average values of within and between each group correlation value for each reference. It summarizes information for all correlation values calculated in the run">> correlation_README.txt

mv correlation_README.txt correlation_analysis/
#
mv  correlation_analysis $The_folder
fi

if [ -f R_all_correlation_errors.txt ]; then
mv R_all_correlation_errors.txt $The_folder
fi

fi

mv map_depth_allrefs $The_folder

if [[ indel == "true" ]];
then
mv indel_info_allrefs $The_folder

fi
mv index_conv.txt $The_folder #for testing

mv Run_summary.csv Errors_README.log base_coverage_summary.csv $The_folder 2> /dev/null
rm -f  *Rplots* Single_summary.csv

if [[ -f normalized_table.csv ]]; then
mv  normalized_table.csv $The_folder

fi 

##### end correlation analysis and organization of output




rm -f  *fofn* *.out  all_refs.fa *.bam
#rm -f -r images-RP  #brew stuff
rm -f -r multi_poly multi_poly_names.txt index_conv.txt #comment when testing




##### checks for -k which says whether to keep bam file in output or not, final code of standard analysis
commands=$@
array=(${commands})
index=0

for k in "${array[@]}"
do

if [[ $k  ==  "-k" ]]; then
echo "transfering"
		mv master_bam $The_folder
fi
		((index ++))
done

rm -f -r master_bam


mv singlecopy_warnings.txt $The_folder 2> /dev/null

mkdir temp 
mv ${The_folder}/index_conv.txt ${The_folder}/The_summary.txt temp
mv *.txt *.fa *_tempi  temp  #.fai
rm -f *.bt2
#design of the cow was borrowed from the famous cowsay package

echo "________________________________"
echo "< The analysis has been completed! >"
echo "--------------------------------"


echo "________________________________"
echo "< WOW what a great pipeline !!!! >"
echo "--------------------------------"
echo "       \   ^__^"
echo "        \  (oo)\_______         "
echo "           (__)\       )\/\  "
echo "               ||----w |    "
echo "               ||     ||    "




if [[ -d $the_path ]]; then
cd ..
The_folder="$currentDate-RP"

mv $The_folder $the_path
fi

fi

##### end of -k check and code for standard analysis code




##### Helps prepare the user_groups input file if pre-corr is used

if [ "$1" == "pre-corr" ]; then
reads=$3

if  [[ $u_or_p_flag == "-u" ]] ||  [[ $u_or_p_flag  ==  "-p" ]] ||  [[ $u_or_p_flag  ==  "-v" ]] || [[ $u_or_p_flag  ==  "-bam" ]]; then
echo "" > /dev/null

else
echo "Incorrect command structure for 'pre-corr'. Refer to repeatprof -h or manual for help"
exit 1
fi

if [ $u_or_p_flag = "-p" ]; then

  ls ${reads}/*_R1.fastq ${reads}/*_R1.gz ${reads}/*_R1.fq ${reads}/*_R1.fq.gz  ${reads}/*_1.fq ${reads}/*_1.fq.gz ${reads}/*_1.gz ${reads}/*_1.fastq ${reads}/*_1.fastq.gz > fofn1.txt 2>/dev/null

  ls ${reads}/*_R2.fastq ${reads}/*_R2.gz ${reads}/*_R2.fq ${reads}/*_R2.fq.gz  ${reads}/*_2.fq.gz  ${reads}/*_2.fq ${reads}/*_2.gz ${reads}/*_2.fastq ${reads}/*_2.fastq.gz > fofn2.txt 2>/dev/null

reads1_check=`cat fofn1.txt | wc -l | xargs`
reads2_check=`cat fofn2.txt | wc -l | xargs`

fi

##### end pre-corr help

#preparing bam files to be used in pre-corr
if [[ $u_or_p_flag = "-bam" ]]; then
bash $mydir/preparing_bam_to_analyze.sh $reads
reads=$(pwd)
reads="$reads/badfastqs-temp-RP"
u_or_p_flag="-u"



fi






##### if user specified unpaired data then look for that. We use it double here because rest of the code was built on paired data, but dont worry it gets dealt with laterye

if [ $u_or_p_flag = "-u" ]; then

if [[ -f $reads ]]; then

if [[ $reads == *.fq ]] || [[ $reads == *.fastq ]] || [[ $reads == *.fq.gz ]] || [[ $reads == *.fastq.gz ]]; then 
ls $reads > fofn1.txt

ls $reads > fofn2.txt

else 

echo "The path to the unpaired reads file(s) is incorrect, or the file(s) is/are in a unsupported format"

echo "Make sure the path is correct (including checking for blanks). Make sure read files have '.fastq' or '.fq' extensions. Compressed (i.e., '.gz') formats also accepted (e.g., 'fastq.gz')."


fi 

else 
  ls ${reads}/*.fastq ${reads}/*.gz ${reads}/*.fq     > fofn1.txt 2>/dev/null
  ls ${reads}/*.fastq ${reads}/*.gz ${reads}/*.fq    > fofn2.txt 2>/dev/null

fi 

fi

if [[ $reads1_check == 0 && $reads2_check == 0 ]];then
echo ""
echo "The path to the paired reads file(s) is incorrect, or the file(s) is/are in a unsupported format"| tee -a Errors_README.log
echo "Make sure your read pairs  are in .fastq or .gz or .fq AND revise the path inputed"| tee -a Errors_README.log
exit 1

fi

if [ "$reads1_check" != "$reads2_check" ]; then
echo "There is one or more pair of reads missing. Ensure all reads read pairs are present in input directory"| tee -a Errors_README.log
exit 1

fi

##### end above block





##### -corr flag can be run as a module independent of a full run. This block takes the output of a previous run and does correlation analysis
$Rscript $mydir/user_groups_maker.R $u_or_p_flag

echo ""

fi

if [ "$1" == "corr" ]; then

if [[ ! -f user_groups.txt ]]; then
echo "user_groups.txt not found in current directory."
echo "Refer to repeatprof -h or the user manual for help"
exit 1 

fi

if  [[ $u_or_p_flag == "-u" ]] ||  [[ $u_or_p_flag  ==  "-p" ]]; then # check if the user inputed -u or -p if not give him an error as it is a madantory command
echo "" > /dev/null

else
echo "Second parameter should be -u or -p"
exit 1

fi

if [[ ! -d $3 ]]; then 
echo "Invalid path to the output folder.refer to repeatprof -h to check command structure"

fi

if [[ ! -d $reads ]]; then 
echo "Invalid path to the reads folder. Please refer to repeatprof -h to check command structure"

fi 

reads=$reads

if [ $u_or_p_flag = "-p" ]; then
  ls ${reads}/*_R1.fastq ${reads}/*_R1.gz ${reads}/*_R1.fq ${reads}/*_R1.fq.gz  ${reads}/*_1.fq ${reads}/*_1.fq.gz ${reads}/*_1.gz ${reads}/*_1.fastq ${reads}/*_1.fastq.gz > fofn1.txt 2>/dev/null

  ls ${reads}/*_R2.fastq ${reads}/*_R2.gz ${reads}/*_R2.fq ${reads}/*_R2.fq.gz  ${reads}/*_2.fq.gz  ${reads}/*_2.fq ${reads}/*_2.gz ${reads}/*_2.fastq ${reads}/*_2.fastq.gz > fofn2.txt 2>/dev/null
reads1_check=`cat fofn1.txt | wc -l | xargs`
reads2_check=`cat fofn2.txt | wc -l | xargs`

fi

if [ $u_or_p_flag = "-u" ]; then

#if user specified unpaired data  then look for that. We make two fofn here for unpaired data because rest of the code was built on paired data, the second copy will be ignored in the end
if [[ -f $reads ]]; then

if [[ $reads == *.fq ]] || [[ $reads == *.fastq ]] || [[ $reads == *.fq.gz ]] || [[ $reads == *.fastq.gz ]]; then 
ls $reads > fofn1.txt
ls $reads > fofn2.txt

else 

echo "The path to the unpaired reads file(s) is incorrect, or the file(s) format is not supported"
echo "Make sure the path is correct (note that spaces in directory names can cause errors). Make sure read files have '.fastq' or '.fq' extensions. Compressed (i.e., '.gz') formats also accepted (e.g., 'fastq.gz')."

fi 

else 
  ls ${reads}/*.fastq ${reads}/*.gz ${reads}/*.fq     > fofn1.txt 2>/dev/null
  ls ${reads}/*.fastq ${reads}/*.gz ${reads}/*.fq    > fofn2.txt 2>/dev/null

fi 

reads1_check=`cat fofn1.txt | wc -l | xargs`
reads2_check=`cat fofn2.txt | wc -l | xargs`

fi


if [[ $reads1_check == 0 && $reads2_check == 0 ]];then
echo ""

echo "The path to the paired reads file(s) is incorrect, or the file(s) is/are in a unsupported format"| tee -a Errors_README.log
echo "Make sure your read pairs  are in .fastq or .gz or .fq, check that the path to the reads is correct"| tee -a Errors_README.log

exit 1

fi

if [ "$reads1_check" != "$reads2_check" ]; then

echo "There is a pair of reads missing. Ensure all reads read pairs are present in input directory"| tee -a Errors_README.log
exit 1

fi


 lines=`cat user_groups.txt | wc -l`
lines=`echo $[$lines-1]`
echo "$lines"
MAX=`wc -l < fofn1.txt`
current=`pwd`

if [[ $lines -ne $MAX ]]; then
           echo "Read files listed in user_groups.txt don't match the read files in path to reads you provided for this run. Ensure that user_groups is correctly formatted, and the path to reads is correct."
		   echo "The user_groups.txt file format does not match read format selected for this run (i.e., -p or -u) If user_groups.txt was formatted for unpaired data, -u must be specified for the run. If formatted for paired data, -p must be specified. See help menu or user manual."
		   exit 1 
 fi		

if [[ -d ${3}/map_depth_allrefs ]]; then
rm -f -r depth_all_cvs
cp  -r ${3}/map_depth_allrefs $current

else
   echo "The output folder structure has been altered. map_depth_allrefs is missing. corr analysis halted"
   exit 1

fi 

if [[ -f ${3}/index_conv.txt ]]; then
rm -f index_conv
cp ${3}/index_conv.txt $current

else
   echo "The output folder structure has been altered. map_depth_allrefs is missing. corr analysis halted"
   exit 1  
   
fi 

rm -f -r  correlation_analysis/
mkdir correlation_analysis
mkdir correlation_analysis/correlation_data
mkdir correlation_analysis/correlation_histograms
mkdir correlation_analysis/correlation_boxplots_by_group
mkdir correlation_analysis/correlation_boxplots_by_reference

## calls script to do modular corr
$Rscript $mydir/all_corr.R $R_packages 1

rm -f -r depth_all_cvs
rm -f index_conv

fi
#####end of modular corr
rm -fr badfastqs-temp-RP




#####code for 'clean' command

if [ "$1" == "clean" ]; then
rm -f -r *bam *fofn* *.out* *multi_poly_names* correlation_analysis *_output* *_conv* *summary* *bt2* *ref_temp* *bowtie.log* *ReadMe* *_cvs* *_temp* *db.2* *Rplots* all_refs.fa references_used #images-RP #brew stuff
rm -f  -r R_all_correlation_errors.txt normalized_table.csv single_cvs Single_summary.csv
echo "remians of a broken run were cleaned successfuly "
fi

##### end 'clean' command




#####code for help menu
if [ "$1" == "-h" ]; then
echo ""
echo "Thank you for checking out RepeatProfiler."
echo "Have a look at our GitHub page (https://github.com/johnssproul/RepeatProfiler) for more info"
echo ""
echo "Usage:"
echo ""
echo "General command structure:"
echo "    repeatprof profile <'-p' for paired-end reads or '-u' for single-end> <filename (or path) of references>" 
echo "                       <path to reads folder> [opitonal flags]"
echo ""
echo "Example command: 'repeatprof profile -p Refs.fa /RepeatProfilerData/Test1'"
echo "    Explanation:"
echo "	'repeatprof' calls the program"
echo "	'profile' command to run primary analysis"
echo "	'-p' tells the program input reads are paired"
echo "	'Refs.fa' name of file with reference sequences (provide path if not in current directory"
echo "	'/RepeatProfilerData/Test1' path to folder with input reads"
echo ""
echo ""
echo "Commands:"
echo "    profile .............. Primary analysis command, see 'Example command' above for required arguments."
echo "    pre-corr ............. Auto-generates user_groups.txt base file for correlation analysis."
echo "    clean ................ Cleans up directory following a terminated/broken run"
echo ""
echo ""
echo "Optional flags:"
echo "    -h ................... Displays help menu."		
echo "    -t ................... Sets the number of threads. Default is 4."
echo "    -k ................... Use this flag to keep bam files in the final output folder."
echo "    -o <folder_path> ..... Directs output to specified folder. Default is current directory."
echo "    -corr ................ Runs a correlation analysis of profile shape among user-defined groups."
echo "  		     	      Requires user_groups.txt input file in current directory. see manual."
echo "    -corr <file_path> .... Used to run correlation analysis when user_groups.txt is not in" 
echo "			      current directory."
echo "    -vertical ............ Generates color-scaled profiles with a vertical color gradient." 
echo " 			      Default is a horizontal gradient."
echo "    -singlecopy .......... Normalizes read coverage of all samples relative to single-copy genes." 
echo "			      Add one or more single-copy sequences to reference sequence file and append" 
echo " 			      their FASTA header with '_singlecopy. see manual.'"
echo "    --<bowtie_command> ... Allows user to change Bowtie 2 mapping parameters. Valid arguments" 
echo " 			      include '--very-fast-local', --fast-local', '--sensitive-local', '--very-sensitive-local',"
echo "			      '--very-fast','--fast', '--sensitive', '--very-sensitive'. In addition to Bowtie 2 presets,"
echo "			      full bowtie command strings may be used. Default is '--very-sensitive-local."
echo ""
echo "Supported input formats:"
echo "    -Reference sequences should be in FASTA format. Valid extensions include: '.fa' .'fasta' '.txt' "
echo ""
echo "    -Input reads should be in FASTQ format (zipped, or not)." 
echo "         -Valid extensions include: '.fastq', '.fq', '.fastq.gz', and '.fq.gz'"
echo "         -For paired reads the last string before the file extension should be ‘_1’ and ‘_2’" 
echo "              for reads 1 and 2 respectively (alternatively ‘_R1’ and ‘_R2’ also supported)"
echo "         -An example of a valid paired read file names is: ‘SampleName_1.fastq.gz’ (read 1)" 
echo "                                                           ‘SampleName_1.fastq.gz’ (read 2)"
echo ""
echo "*Check our github page https://github.com/johnssproul/RepeatProfiler for more info"

fi

if [ "$1" == "-cow" ]; then

echo "________________________________"
echo "< WOW what a great pipeline !!!! >"
echo "--------------------------------"
echo "       \   ^__^"
echo "        \  (oo)\_______         "
echo "           (__)\       )\/\  "
echo "               ||----w |    "
echo "               ||     ||    "
fi
##### end help menu
